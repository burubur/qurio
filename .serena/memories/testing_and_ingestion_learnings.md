- **Database Constraints & Testing:** Partial unique indexes (e.g., `WHERE deleted_at IS NULL`) and constraints like `ON DELETE CASCADE` cannot be reliably tested with `sqlmock`. They require real database integration tests (using Testcontainers) to verify behavior correctness.
- **MCP Testing:** Testing async SSE flows requires integration tests to verify context propagation (Correlation IDs) as unit tests often miss the goroutine context detachment/cancellation nuances.
- **Handler Integration Tests:** For handlers involving multipart uploads or complex state (like SSE sessions), use `httptest` combined with `IntegrationSuite`. This allows verifying side effects (files on disk, DB state) which unit tests with mocks cannot cover.
- **Testcontainers Pattern:**
    - Use `IntegrationSuite` struct to manage Postgres, Weaviate, and NSQ containers.
    - Setup in `TestMain` or per-test `Setup()` to ensure isolation.
    - Use `testcontainers.WithWaitStrategy` to ensure services are fully ready before running tests.
    - Expose dynamic ports via `GetAppConfig()` to configure clients/handlers under test.
- **Ingestion Worker Testing:**
    - **PYTHONPATH:** When running `pytest` for the ingestion worker, explicitly set `PYTHONPATH=.` (e.g., `PYTHONPATH=. ./venv/bin/pytest`) to ensure local modules (like `handlers`, `config`, `logger`) are correctly resolved.
    - **Dead Code:** Unused imports and variables (e.g., redundant semaphores, unused `exclusions` params) can accumulate. Periodic cleanup using static analysis or manual review is recommended to keep the worker codebase lean.
